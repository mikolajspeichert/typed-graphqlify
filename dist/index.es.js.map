{"version":3,"file":"index.es.js","sources":["../src/render.ts","../src/graphqlify.ts","../src/types.ts"],"sourcesContent":["/**\n * Defines the type of the object\n */\nexport enum GraphQLType {\n  SCALAR,\n  INLINE_FRAGMENT,\n  FRAGMENT,\n}\n\n/**\n * The symbol to use to store the object GQL type\n */\nexport const typeSymbol = Symbol('GraphQL Type')\n\n/**\n * The symbol to use to store the object parameters.\n */\nexport const paramsSymbol = Symbol('GraphQL Params')\n\n/**\n * The parameters type.\n */\nexport interface Params {\n  [key: string]: string | boolean | number | Params\n}\n\n/**\n * A GQL inline fragment.\n */\nexport interface GraphQLInlineFragment {\n  [typeSymbol]: GraphQLType.INLINE_FRAGMENT\n  typeName: string\n  internal: Record<string, unknown>\n}\n\n/**\n * Checks whether an object is a fragment object.\n */\nfunction isInlineFragmentObject(value: unknown): value is GraphQLInlineFragment {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    (value as any)[typeSymbol] === GraphQLType.INLINE_FRAGMENT\n  )\n}\n\n/**\n * A GQL fragment.\n */\nexport interface GraphQLFragment {\n  [typeSymbol]: GraphQLType.FRAGMENT\n  name: string\n  typeName: string\n  internal: Record<string, unknown>\n}\n\n/**\n * Checks whether an object is a fragment object.\n */\nfunction isFragmentObject(value: unknown): value is GraphQLFragment {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    (value as any)[typeSymbol] === GraphQLType.FRAGMENT\n  )\n}\n\n/**\n * A GQL scalar object.\n * Stores the params of the scalar if any were given.\n */\nexport interface GraphQLScalar {\n  [typeSymbol]: GraphQLType.SCALAR\n  [paramsSymbol]?: Params\n}\n\n/**\n * Checks whether an object is a scalar object.\n */\nfunction isScalarObject(value: unknown): value is GraphQLScalar {\n  return (\n    typeof value === 'object' && value !== null && (value as any)[typeSymbol] === GraphQLType.SCALAR\n  )\n}\n\n/**\n * Provides the context for the current render.\n */\ninterface RenderContext {\n  fragments: Map<symbol, GraphQLFragment>\n}\n\n/**\n * Renders the name if it was given.\n */\nfunction renderName(name: string | undefined): string {\n  return name === undefined ? '' : name\n}\n\n/**\n * Renders the parameters if they were given.\n */\nfunction renderParams(params?: Params, brackets = true): string {\n  if (!params) {\n    // If no params are given, don't render anything.\n    return ''\n  }\n\n  const builder: string[] = []\n  for (const [key, value] of Object.entries(params)) {\n    let params: string\n    if (typeof value === 'object') {\n      params = `{${renderParams(value, false)}}`\n    } else if (typeof value === 'string') {\n      params = `\"${value}\"`\n    } else {\n      params = `${value}`\n    }\n    builder.push(`${key}:${params}`)\n  }\n\n  let built = builder.join(',')\n  if (brackets) {\n    built = `(${built})`\n  }\n  return built\n}\n\n/**\n * Renders a GQL scalar.\n */\nfunction renderScalar(name: string | undefined, params?: Params): string {\n  // Scalars have no content, just a name.\n  return renderName(name) + renderParams(params)\n}\n\n/**\n * Renders a GQL inline fragment.\n */\nfunction renderInlineFragment(fragment: GraphQLInlineFragment, context: RenderContext): string {\n  return `...on ${fragment.typeName}${renderObject(undefined, fragment.internal, context)}`\n}\n\n/**\n * Renders a GQL fragment.\n */\nfunction renderFragment(fragment: GraphQLFragment, context: RenderContext): string {\n  return `fragment ${fragment.name} on ${fragment.typeName}${renderObject(\n    undefined,\n    fragment.internal,\n    context,\n  )}`\n}\n\n/**\n * Renders a GQL array.\n */\nfunction renderArray(name: string | undefined, arr: unknown[], context: RenderContext): string {\n  // Get first item.\n  const first = arr[0]\n\n  // Ensure we have something.\n  if (first === undefined || first === null) {\n    throw new Error('Cannot render array with no first value')\n  }\n\n  // Move params onto rendered item.\n  ;(first as any)[paramsSymbol] = (arr as any)[paramsSymbol]\n\n  // Render type normally.\n  return renderType(name, first, context)\n}\n\n/**\n * Renders the given value into its given GQL.\n */\nfunction renderType(name: string | undefined, value: unknown, context: RenderContext): string {\n  switch (typeof value) {\n    case 'bigint':\n    case 'boolean':\n    case 'number':\n    case 'string':\n      throw new Error(`Rendering type ${typeof value} directly is disallowed`)\n    case 'object':\n      // Ignore null fields.\n      if (value === null) {\n        throw new Error('Cannot render null')\n      }\n      if (isScalarObject(value)) {\n        return `${renderScalar(name, value[paramsSymbol])} `\n      } else if (Array.isArray(value)) {\n        return renderArray(name, value, context)\n      } else {\n        return renderObject(name, value, context)\n      }\n    case 'undefined':\n      // Ignore undefined values.\n      return ''\n    default:\n      throw new Error(`Cannot render type ${typeof value}`)\n  }\n}\n\n/**\n * Renders a object to GQL.\n */\nfunction renderObject(name: string | undefined, obj: object, context: RenderContext): string {\n  const fields: string[] = []\n\n  // Iterate normal properties and render them accordingly.\n  for (const [key, value] of Object.entries(obj)) {\n    fields.push(renderType(key, value, context))\n  }\n\n  // Search for fragment & inline fragment symbols and render them.\n  for (const sym of Object.getOwnPropertySymbols(obj)) {\n    const value = (obj as any)[sym]\n    if (isInlineFragmentObject(value)) {\n      fields.push(renderInlineFragment(value, context))\n    } else if (isFragmentObject(value)) {\n      context.fragments.set(sym, value)\n      fields.push(`...${value.name}`)\n    }\n  }\n\n  // Validate that we have fields to render.\n  if (fields.length === 0) {\n    throw new Error('Object cannot have no fields')\n  }\n\n  // Render function object.\n  return `${renderName(name)}${renderParams((obj as any)[paramsSymbol])}{${fields.join('').trim()}}`\n}\n\n/**\n * Performs a complete render of a given object.\n */\nexport function render(value: Record<string, unknown>): string {\n  // Construct main render context.\n  const context: RenderContext = {\n    fragments: new Map(),\n  }\n\n  // Render main body.\n  let rend = renderObject(undefined, value, context)\n\n  // Render the fragments defined in each context until we have no more to render.\n  const rendered = new Map<symbol, string>()\n  let executingContext = context // The context we're currently executing over.\n  let currentContext: RenderContext = {\n    // The current context for execution.\n    fragments: new Map(),\n  }\n  while (executingContext.fragments.size > 0) {\n    // Use Array.from due to ES5 target without downLevelIteration enabled.\n    for (const [sym, fragment] of Array.from(executingContext.fragments.entries())) {\n      // We only need to render the fragment once, even if it's used multiple times.\n      if (!rendered.has(sym)) {\n        rendered.set(sym, renderFragment(fragment, currentContext))\n      }\n    }\n\n    // Set the next context to execute to the one we just used.\n    executingContext = currentContext\n    currentContext = {\n      // Reset current context.\n      fragments: new Map(),\n    }\n  }\n\n  return rend + Array.from(rendered.values()).join('')\n}\n","import { GraphQLFragment, GraphQLType, Params, paramsSymbol, render, typeSymbol } from './render'\n\ninterface QueryObject {\n  [x: string]: any\n}\n\nfunction createOperate(operateType: string) {\n  function operate(queryObject: QueryObject): string\n  function operate(operationName: string, queryObject: QueryObject): string\n  function operate(opNameOrQueryObject: string | QueryObject, queryObject?: QueryObject): string {\n    if (typeof opNameOrQueryObject === 'string') {\n      if (!queryObject) {\n        throw new Error('queryObject is not set')\n      }\n      return `${operateType} ${opNameOrQueryObject}${render(queryObject)}`\n    }\n    return `${operateType}${render(opNameOrQueryObject)}`\n  }\n  return operate\n}\n\nexport const query = createOperate('query')\nexport const mutation = createOperate('mutation')\nexport const subscription = createOperate('subscription')\n\nexport function params<T>(params: Params, input: T): T {\n  if (typeof params !== 'object') {\n    throw new Error('Params have to be an object')\n  }\n  if (typeof input !== 'object') {\n    throw new Error(`Cannot apply params to JS ${typeof params}`)\n  }\n\n  ;(input as any)[paramsSymbol] = params\n  return input\n}\n\nexport function alias<T extends string>(alias: T, target: string): T {\n  return `${alias}:${target}` as T\n}\n\nexport function fragment<T extends Record<string, unknown>>(\n  name: string,\n  typeName: string,\n  input: T,\n): T {\n  const fragment: GraphQLFragment = {\n    [typeSymbol]: GraphQLType.FRAGMENT,\n    name,\n    typeName,\n    internal: input,\n  }\n\n  return { [Symbol(`Fragment(${name} on ${typeName})`)]: fragment } as any\n}\n\n/**\n * prevent `String` param being rendered as enum\n */\nexport function rawString(input: string) {\n  return JSON.stringify(input)\n}\n","import { typeSymbol, GraphQLType, GraphQLScalar, GraphQLInlineFragment } from './render'\n\n// Utility type\ntype ValueOf<T> = T[keyof T]\n\nexport function optional<T>(obj: T): T | undefined {\n  return obj\n}\n\nexport function on<T extends {}>(typeName: string, internal: T): Partial<T> {\n  const fragment: GraphQLInlineFragment = {\n    [typeSymbol]: GraphQLType.INLINE_FRAGMENT,\n    typeName,\n    internal,\n  }\n  return { [Symbol(`InlineFragment(${typeName})`)]: fragment } as any\n}\n\nexport function onUnion<T>(types: Record<string, T>): T {\n  let fragments: Record<any, T> = {}\n  for (const [typeName, internal] of Object.entries(types)) {\n    fragments = {\n      ...fragments,\n      ...on(typeName, internal),\n    }\n  }\n  return fragments as any\n}\n\nfunction scalarType(): any {\n  const scalar: GraphQLScalar = {\n    [typeSymbol]: GraphQLType.SCALAR,\n  }\n  return scalar\n}\n\nexport class types {\n  static get number(): number {\n    return scalarType()\n  }\n\n  static get string(): string {\n    return scalarType()\n  }\n\n  static get boolean(): boolean {\n    return scalarType()\n  }\n\n  static constant<T extends string>(_c: T): T {\n    return scalarType()\n  }\n\n  static oneOf<T extends {}>(_e: T): ValueOf<T> {\n    return scalarType()\n  }\n\n  static custom<T>(): T {\n    return scalarType()\n  }\n\n  static optional: {\n    number?: number\n    string?: string\n    boolean?: boolean\n    constant: <T extends string>(_c: T) => T | undefined\n    oneOf: <T extends {}>(_e: T) => (ValueOf<T>) | undefined\n    custom: <T>() => T | undefined\n  } = types\n}\n"],"names":[],"mappings":"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"}